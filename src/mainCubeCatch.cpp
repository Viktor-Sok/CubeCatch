#include <string>
#include <iostream>
#include <exception>
//#include <fstream>
#include <cstring> // provides additional functionality to work with strings and chars ( like <string>.c_str() )
#include "egm.pb.h" // generated by Google protoc.exe
#include "udp_server.h"
#include "trajectory_planner.h"
#include "CubeRecognition.h"
#include <iostream>
#include <cmath>
//#include <chrono>
//#include<tuple>
//#include <thread>
#include <Eigen/Dense>
using namespace abb::egm;
//using namespace std::chrono;

const int portNumber = 6510;
unsigned int sequenceNumber = 0;
double t = 0 ; // seconds
//static double degrees = 0;



bool CreateCartesianMessage(EgmSensor* pSensorMessage, EgmRobot* pRobotMessage, TrajectoryPlanner& poly3, cv::Vec2d& center, double angle)

{
    //double x_current = pRobotMessage->feedback().joints().joints(5);
    double x_current = pRobotMessage->feedback().cartesian().pos().x();
    
    double y_current = pRobotMessage->feedback().cartesian().pos().y();
    double z_current = pRobotMessage->feedback().cartesian().pos().z();
    //std::cout << x_current << " " << y_current << " " << z_current<< std::endl; 
    //std::cout << center(0) << " " << center(1);
    if (((std::abs(center(0) - x_current) < 1.5)&&(std::abs(center(1) - y_current) < 1.5))|| z_current > -50) {
        std::cout <<"Condition Fulfilled"<< std::endl;
        return false;
    }
    /*
    if ((poly3.t_fin - t) < 0.004)
    {
        // indicates the end of the trajectory
        return false;
    }
    */
    // reference degrees for the joints
    //EgmHeader* header = new EgmHeader();
	//header->set_mtype(abb::egm::EgmHeader_MessageType_MSGTYPE_CORRECTION);
	//header->set_seqno(seq_no++);
	//header->set_tm((unsigned __int32)GetTickCount64());
    //Set cartesian space position values for the robot
    EgmCartesian *robc = new EgmCartesian();
    // z is the Motion generator in this particular case
    double z = poly3.getMotionGenerator(t);
    double x, y;
    std::tie(x, y) = poly3.straightLine3D(z);
    //x = poly3.straightLine2D(z);
    robc->set_x(x);
    robc->set_y(y);
	robc->set_z(z);
    
    EgmEuler *robeu = new EgmEuler();
	robeu->set_x(0);
	robeu->set_y(0);
	robeu->set_z(angle);
    /*
    EgmQuaternion *robq = new EgmQuaternion();
    robq -> set_u0(0.707);
    robq -> set_u1(-0.707);
    robq -> set_u2(0);
    robq -> set_u3(0);
    */
	//abb::egm::EgmEuler *robeu = new abb::egm::EgmEuler();
    EgmPose *robcartesian = new EgmPose();
	//robcartesian->set_allocated_euler(robeu);
	robcartesian->set_allocated_pos(robc);
    robcartesian->set_allocated_euler(robeu);
    //robcartesian -> set_allocated_orient(robq);
	// setting reference degrees for the <planned> field of EGMSensor data structure;
    EgmPlanned *pPlanned = new EgmPlanned();
    pPlanned->set_allocated_cartesian(robcartesian);
    pSensorMessage->set_allocated_planned(pPlanned);
    

    // message Header in egm.proto file
    EgmHeader* pHeader = new EgmHeader();
    pHeader->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    pHeader->set_seqno(sequenceNumber++); // encreases for each message server sends
    pHeader->set_tm(GetTickCount());// timestamp, e.g. for monitoring delays
    //std::cout << sizeof(EgmHeader) << std::endl;
    //Set cartesian space position values for the robot
	 // provides Header to the SensorMessage data structure
    pSensorMessage->set_allocated_header(pHeader);
    t += 0.020;
    return true;
}


int main(int argc, char *argv[]) 
{
    // buffers for sending and receiving the messages
    std::string writeBuffer;
    char readBuffer[1400];
    //std::tuple<char*, int> receivedData; // stores received buffer from the Robot and number of bytes
    // instantiate socket object
    cv::Vec2d center;
    double angle;
    
    CubeDetector detector("intrinsics.json", "extrinsics.json");
    try {
        std::tie(center, angle) = detector.detectCube(true);
    } catch (std::exception& ex) { //exception is the class which all exceprions are inhereted from
        std::cout << "Exception happened: " << ex.what() << std::endl; // ex.what() returns description of the error
        getchar();
        return -1;
    }
    
    std::cout << "Additional Safety Check: the following coordinates will be passed to the EGM module." << std::endl;
    std::cout << "x = " << center(0)  << " mm, "<< "y = " << center(1)<< " mm, " << "angle = " << angle << " degrees" << std::endl;
    
    TrajectoryPlanner polyn3(0.0, 30.0, Vector4d(-356.28, 0, -60, 0), Vector4d(521.15, center(0), 110.33, center(1)));  // related to initial fine point in workobject coord syst
    polyn3.thirdDegreePolynomial(); // finds coefficients of 3rd degree polynomial for the motion generator
    UdpServer udpSocket(portNumber);
    // pointers to the EgmRobot  and EgmSensor data structure
    EgmRobot *pRobotMessage = new EgmRobot();
    EgmSensor *pSensorMessage = new EgmSensor();
    int bytesReceived, bytesSent;
    bool running = true;
    //bool running1 = true; // to determing whether the planned trajectory has been completed
    //int lostMessages = 0;
    //WriteRobotLogFile  writeRobot; // thread 2
    //WriteSensorLogFile writeSensor; // thread 3
    //DisplayRobotMessageInTerminal printRobot; //thread 4
    //pRobotMessage -> feedback().joints().joints(0);
    //int a = 0;
    // x_f, y_f , angle - from Cube Detector
    // x_i, y_i, z_i - are known from Home Position (or using feedback)
    // z_f - are known -60 mm from the table
    
    while(true)
    {
        //receiving messages
        bytesReceived = udpSocket.read(readBuffer);
        
        if (bytesReceived == -1)
        {
            std::cout << udpSocket.status() << std::endl;
            continue;
        }
        pRobotMessage->ParseFromArray(readBuffer, bytesReceived); // deserialization
		
        //receivedData = std::make_tuple(readBuffer,bytesReceived);
        // sending messages
        //running = CreateJointMessage(pSensorMessage);
        running = CreateCartesianMessage(pSensorMessage, pRobotMessage, polyn3, center, angle);
            //std::cout<<"EGM task finished! Waiting for the robot message to start the next task... "<<std::endl;
        
        /*
        else
        {
            if(a==0) 
            {
                std::this_thread::sleep_for(std::chrono::microseconds(100000));
                ++a;
                continue;
            }
            running1 = CreateJointMessage1(pSensorMessage);
        }
        */
        if(running==false)
        {
            std::cout << "Program finished. Type in any charachter to exit...\n";
            break;
        }
        
        //writeRobot.writeOut(receivedData);
        //printRobot.writeOut(receivedData);
        //writeSensor.writeOut(pSensorMessage);
        pSensorMessage->SerializeToString(&writeBuffer);
        bytesSent = udpSocket.write(writeBuffer);
        
        if (bytesSent == -1)
        {
            std::cout << udpSocket.status() << std::endl;
            break;
        }
        
        
    }
    
    // cleaning up resources
    delete pRobotMessage;
    delete pSensorMessage;
    //getchar();
    std::cout<<"Type any charachter to quit the program...\n";
    std::getchar();
    return 0;
    
}
